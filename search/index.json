<<<<<<< HEAD
[{"content":"图？树？ 在我们写题目之前我们应该学习一下图和树的存贮方式 1.邻阶矩阵\n2.邻接表\n3.链式前向星（静态链表）\n掌握这些基础的存储方式我们才能解决关于图和树的问题，请各位同学自行学习\n`\n[p5318查找文献](P5318 【深基18.例3】查找文献 - 洛谷) 题目大意 其实就是给你一张有向图，要你把它深度遍历一遍再广度遍历一遍。\n题解 用bfs和dfs遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 struct edge{ //存边结构体 int u,v; }; vector \u0026lt;int\u0026gt; e[100001]; vector \u0026lt;edge\u0026gt; s; bool vis1[100001]={0},vis2[100001]={0}; //标记数组 void dfs(int x){ //深度优先遍历 vis1[x]=1; cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;; for(int i=0;i\u0026lt;e[x].size();i++){ int point=s[e[x][i]].v; if(!vis1[point]){ dfs(point); } } } void bfs(int x){ //广度优先遍历 queue \u0026lt;int\u0026gt; q; q.push(x); cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;; vis2[x]=1; while(!q.empty()){ int fro=q.front(); for(int i=0;i\u0026lt;e[fro].size();i++){ int point=s[e[fro][i]].v; if(!vis2[point]){ q.push(point); cout\u0026lt;\u0026lt;point\u0026lt;\u0026lt;\u0026#34; \u0026#34;; vis2[point]=1; } } q.pop(); } } [B3647 【模板】Floyd](B3647 【模板】Floyd - 洛谷) 题目大意 给n个点和m跳边组成的无向图，求所有（i，j）的最短路径\n数据范围 对于 100% 的数据，n≤100，m≤4500，任意一条边的权值 w 是正整数且 1⩽w⩽1000。\n题解 Floyd的板子题~~（本质上是动态规划）~~f[i] [j]为i到j的最短路径 本质上是一个三维状态数组f[i] [j] [k]为从i到j期间经过了1到k这些点\n1 2 3 4 for(int k=1; k\u0026lt;=n; k++) for(int i=1; i\u0026lt;=n; i++) for(int j=1; j\u0026lt;=n; j++) f[i][j]=min(f[i][j],f[i][k]+f[k][j]); 参考写法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void solve () { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;++i)for(int j=1;j\u0026lt;=n;++j){ if(i==j)dis[i][j]=0; else dis[i][j]=INF; } int v1,v2;ll w; for(int i=0;i\u0026lt;m;++i){ cin\u0026gt;\u0026gt;v1\u0026gt;\u0026gt;v2\u0026gt;\u0026gt;w; //\tdis[v1][v2]=dis[v2][v1]=w; //取重边时较小的边 dis[v2][v1]=dis[v1][v2]=min(dis[v1][v2],w); //\tdis[v2][v1]=min(dis[v2][v1],w); } for(int k=1;k\u0026lt;=n;++k){ for(int i=1;i\u0026lt;=n;++i){ for(int j=1;j\u0026lt;=n;++j){ if((i!=j)\u0026amp;\u0026amp;(i!=k)\u0026amp;\u0026amp;(j!=k)) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); } } } for(int i=1;i\u0026lt;=n;++i){ for(int j=1;j\u0026lt;=n;++j){ if(j\u0026gt;1)cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;dis[i][j]; } cout\u0026lt;\u0026lt;endl; } ","date":"2025-04-04T17:58:40+08:00","image":"http://localhost:1313/p/%E5%9B%BE%E8%AE%BA-%E6%A0%91/cdb444913e4e2f7244e03d4f25c15e2_hu_909a17b544b439f4.jpg","permalink":"http://localhost:1313/p/%E5%9B%BE%E8%AE%BA-%E6%A0%91/","title":"图论+树"},{"content":"数据结构（进阶一点） 1.单调队列 例题：[洛谷p1886 滑动窗口](P1886 滑动窗口 /【模板】单调队列 - 洛谷) 题目描述 有一个长为 n 的序列 a，以及一个大小为 k 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。\n输入格式 输入一共有两行，第一行有两个正整数 n,k。 第二行 n 个整数，表示序列 a\n输出格式 输出共两行，第一行为每次窗口滑动的最小值 第二行为每次窗口滑动的最大值\n样例 输入：\n1 2 8 3 1 3 -1 -3 5 3 6 7 输出：\n1 2 -1 -3 -3 -3 3 3 3 3 5 5 6 7 单调队列的性质 1.队列中的元素其对应在原来的列表中的顺序必须是单调递增的。\n2.队列中元素的大小必须是单调递*(增/减/甚至是自定义也可以)\n核心思想是老而更劣的元素永远不可能成为最值\n例如：在从左往右滑动窗口求最小值时，考虑右侧新加入一个元素 aj时会发生什么。假设区间中已经有的一个元素 ai 使得 ai≥aj，那么 aj 离开窗口一定比 ai 要晚，且今后 ai 在队列里的时候 aj 也一直在队列里。在 \\ai\\剩下的生命里直到离开区间，aj 永远比它小，ai 再也不可能成为（唯一的）最小值了**。\ncode: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include\u0026lt;bits/stdc++.h\u0026gt; #define int long long using namespace std; const int N=1e6+5,inf=1e18; int n,m; int a[N]; int q[N]; signed main(){ ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; } int l=1,r=0; for(int i=1;i\u0026lt;=n;i++){ while(l\u0026lt;=r \u0026amp;\u0026amp; a[q[r]]\u0026gt;=a[i]){ r--; } while(l\u0026lt;=r \u0026amp;\u0026amp; q[l]+m\u0026lt;=i){ l++; } q[++r]=i; if(i\u0026gt;=m){ cout\u0026lt;\u0026lt;a[q[l]]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } } cout\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; l=1,r=0; for(int i=1;i\u0026lt;=n;i++){ while(l\u0026lt;=r \u0026amp;\u0026amp; a[q[r]]\u0026lt;=a[i]){ r--; } while(l\u0026lt;=r \u0026amp;\u0026amp; q[l]+m\u0026lt;=i){ l++; } q[++r]=i; if(i\u0026gt;=m){ cout\u0026lt;\u0026lt;a[q[l]]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } } return 0; } `\n","date":"2025-04-03T17:58:40+08:00","image":"http://localhost:1313/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/e2d0ddb96666f3ca41a084d11a45225e_hu_7f9702c132a88c6e.png","permalink":"http://localhost:1313/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","title":"数据结构"},{"content":"小羊第一次写也很激动 第一次写自己的博客，以后会慢慢美化的！！ 1.放点神秘春卷饭\n2.搞个音乐\n3.放个看板娘\n4.动态加载页面\n5.第五人格启动\n","date":"2025-04-03T01:58:40+08:00","image":"http://localhost:1313/p/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/QQ_1743621657874_hu_a17ee49cf51cb377.png","permalink":"http://localhost:1313/p/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/","title":"第一个博客！"}]
=======
[{"content":"小羊第一次写也很激动 第一次写自己的博客，以后会慢慢美化的！！ 1.放点神秘春卷饭\n2.搞个音乐\n3.放个看板娘\n4.动态加载页面\n5.第五人格启动\n","date":"2025-04-03T01:58:40+08:00","image":"http://localhost:1313/p/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/QQ_1743621657874_hu_a17ee49cf51cb377.png","permalink":"http://localhost:1313/p/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/","title":"第一个博客！"}]
>>>>>>> 0591b21d706af52db90f6fe64a1ffc3eb4cf3aaf
